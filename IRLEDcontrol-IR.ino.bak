
#include <IRremote.h>

int RECV_PIN = 2; //data out of IR receiver connects to pin 2

int bright;

int OUTPUT_RED   =  9;
int OUTPUT_GREEN = 10;
int OUTPUT_BLUE  = 11;

int steps=5; //dimmer steps, vary those to increase/decrease the steps between full brightness and turned off

unsigned long CODE_RED    = 551505585;
unsigned long CODE_GREEN  = 551521905;
unsigned long CODE_YELLOW = 551536185;
unsigned long CODE_BLUE   = 551519865;
unsigned long CODE_LONG_PRESS = 4294967295;

unsigned long BTN_TOGGLE = CODE_RED;
unsigned long BTN_COLOR_CHANGE = CODE_GREEN;
unsigned long BTN_BRIGHTNESS_CHANGE = CODE_GREEN;


struct struct_color { 
    int r;
    int g;
    int b;
};
typedef struct struct_color color;

//                           WHITE                     RED                    ORANGE                 YELLOW                 PINK                   BLUE
color colorArray[] = {{.r=255, .g=255, .b=255}, {.r=255, .g=0, .b=0}, {.r=255, .g=100, .b=0}, {.r=255, .g=255, .b=0}, {.r=255, .g=0, .b=255}, {.r=0, .g=0, .b=255}};
int colorCount = 6;

int current_color_id = 0;
color current_output = colorArray[current_color_id];


int getIdOfNextColor() {
    if(++current_color_id >= colorCount){
      current_color_id = 0;
    }
    return current_color_id;
}


IRrecv irrecv(RECV_PIN);

decode_results results;

void setup(){
  irrecv.enableIRIn(); // start the receiver
  bright=255; //brightness value is at maximum (255)
  pinMode(OUTPUT_RED,   OUTPUT);
  pinMode(OUTPUT_GREEN, OUTPUT);
  pinMode(OUTPUT_BLUE,  OUTPUT);

  // start with off state...
  current_output.r = 255;
  current_output.g = 0;
  current_output.b = 0;

  Serial.begin(9600);
}

void loop() {
  if (irrecv.decode(&results)) {
    Serial.print(results.value);

    if (results.value == BTN_TOGGLE) { // need to turn ON or OFF
      if( (current_output.r > 10) || (current_output.g > 10) || (current_output.b > 10)){  // it means it is turned ON now
        // so we need to turn it OFF:
        digitalWrite(OUTPUT_RED,   LOW);  
        digitalWrite(OUTPUT_GREEN, LOW);  
        digitalWrite(OUTPUT_BLUE,  LOW); 
        Serial.print("    OFF   "); 
      } else { // it means it is turned OFF now
        Serial.print("    ON   "); 
        current_color_id = 0; //white
        current_output = colorArray[current_color_id];
        analogWrite(OUTPUT_RED,   current_output.r);
        analogWrite(OUTPUT_GREEN, current_output.g);
        analogWrite(OUTPUT_BLUE,  current_output.b);/**/
      }
    } else

    if (results.value == BTN_COLOR_CHANGE) { //Code to turn the LED ON/OFF
      current_output = colorArray[getIdOfNextColor()];
      Serial.print(" ColorID: ");
      Serial.print(current_color_id);
      analogWrite(OUTPUT_RED,   current_output.r);
      analogWrite(OUTPUT_GREEN, current_output.g);
      analogWrite(OUTPUT_BLUE,  current_output.b);
    }
     
  /*
  if (results.value==0x20DF8D72){ //Code to turn the LED ON/OFF
    if(before==0){ // if the LED was turned off, then we turn it on 
      digitalWrite(out,HIGH);
      before=1; //LED is now turned on
    }
    else{
      digitalWrite(out,LOW); //if the LED was turned on, then we turn it off
      before=0;
      bright=255; 
    }}
  if (results.value==0x20DFF10E && before==1){ //Code to decrease the brightness
    if(bright-255/steps<0){ 
      analogWrite(out,bright);
    }
    else{
    bright=bright-255/steps;
    analogWrite(out,bright);
  }}
  if (results.value==0x20DF718E && before==1){ //Code to increase the brightness
    if(bright+255/steps>255){
      analogWrite(out,bright);
    }
    else{    
    bright=bright+255/steps;
    analogWrite(out,bright);
  }}
  /**/
  
  irrecv.resume();
}}




